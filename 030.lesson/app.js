/*
function func() {
    window.smth = "Humoyun";
};

func();
*/

const someRes = getData();
const node = document

//====================================================================================================================
// Сборщик мусора и утечки памяти в JS

/**
 * Сборщик мусора (Garbage Collector) в JavaScript - это механизм, который автоматически отслеживает и 
 * освобождает память, занимаемую объектами, которые больше не доступны. Это делает язык более удобным 
 * для программистов, так как они не должны явно управлять выделением и освобождением памяти.

Однако, утечки памяти могут все равно возникнуть, если программисты не осторожны при работе с объектами и 
ссылками. Вот некоторые распространенные причины утечек памяти в JavaScript:

1. **Циклические ссылки:**
   - Если два или более объекта ссылаются друг на друга, и нет других ссылок на эти объекты из внешнего кода, 
   то сборщик мусора не может освободить память, занятую этими объектами.
   - Пример:
     ```javascript
     let obj1 = {};
     let obj2 = {};
     obj1.ref = obj2;
     obj2.ref = obj1;
     ```

2. **Неявные ссылки:**
   - Иногда ссылки на объекты могут оставаться в замыканиях или других структурах данных, даже если 
   программист не предполагал, что объект должен сохраняться.
   - Пример:
     ```javascript
     function createObject() {
       let localVar = {};
       // localVar остается в замыкании, даже после завершения функции
       return function() {
         console.log(localVar);
       };
     }

     let myFunction = createObject();
     ```

3. **Неосвобождение ресурсов:**
   - Если объект содержит ресурсы, такие как сетевые соединения или файлы, и эти ресурсы не 
   освобождаются явно, это может привести к утечкам памяти.
   - Например, не закрытое сетевое соединение может привести к утечке памяти.

4. **Использование больших массивов и структур данных:**
   - Создание и хранение больших массивов или структур данных может привести к утечкам памяти, если они не управляются правильно.

Для предотвращения утечек памяти в JavaScript, следует следующие практики:

- Избегайте циклических ссылок, особенно там, где они не нужны.
- Освобождайте ресурсы явно, когда они больше не нужны, например, закрывайте сетевые соединения или 
освобождайте ресурсы в обработчиках событий.
- Используйте инструменты разработчика браузера для профилирования и анализа использования памяти.

Хорошее знание жизненного цикла объектов в JavaScript и умение использовать инструменты для отслеживания и
 анализа утечек памяти могут существенно помочь в предотвращении проблем с памятью.
 */


//==================================================================================================================


//  https://tproger.ru/translations/upravlenie-pamjatju-v-javascript

//==================================================================================================================
//=================================================`WeakMap` и `WeakSet`============================================
//==================================================================================================================

/**
 * `WeakMap` и `WeakSet` - это специальные коллекции в языке JavaScript, которые используют слабые ссылки
 *  для хранения ключей. Они отличаются от `Map` и `Set` тем, что не предотвращают сборку мусора для своих
 *  ключей. Это означает, что если объект является ключом в `WeakMap` или элементом в `WeakSet`, и на него
 *  нет других ссылок из кода, он может быть удален из памяти сборщиком мусора.

1. **WeakMap:**
   - `WeakMap` представляет собой коллекцию, в которой ключами могут быть только объекты.
   - Ключи `WeakMap` являются слабыми ссылками, что означает, что они не участвуют в процессе сборки мусора.
    Если нет других ссылок на объект-ключ, он может быть удален сборщиком мусора, и это приведет к автоматическому
     удалению соответствующей записи из `WeakMap`.
   - `WeakMap` не имеет методов, позволяющих получать список всех ключей или значений.

Пример использования `WeakMap`:

```javascript
let weakMap = new WeakMap();

let key = {};
let value = 'Значение';

weakMap.set(key, value);
console.log(weakMap.get(key)); // Выведет: 'Значение'

// Если убрать все ссылки на ключ, он может быть удален сборщиком мусора,
// и связанное с ним значение также будет удалено из WeakMap.
key = null;

// Теперь, если попытаться получить значение по ключу, получим undefined.
console.log(weakMap.get(key)); // Выведет: undefined
```

2. **WeakSet:**
   - `WeakSet` представляет собой коллекцию, в которой элементами могут быть только объекты.
   - Элементы `WeakSet` также являются слабыми ссылками, и также, как и в случае с `WeakMap`, если на объект-элемент
    нет других ссылок, он может быть удален сборщиком мусора.
   - `WeakSet` не имеет методов, позволяющих получать список всех элементов.

Пример использования `WeakSet`:

```javascript
let weakSet = new WeakSet();

let obj1 = {};
let obj2 = {};

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // Выведет: true

// Если убрать все ссылки на obj1, он может быть удален сборщиком мусора,
// и соответствующая запись в WeakSet также будет удалена.
obj1 = null;

console.log(weakSet.has(obj1)); // Выведет: false
```

Использование `WeakMap` и `WeakSet` оправдано, когда вам нужно хранить ассоциации или коллекции объектов, 
но вы не хотите, чтобы эти объекты препятствовали сборке мусора, когда больше не используете их в других частях кода.
 */




